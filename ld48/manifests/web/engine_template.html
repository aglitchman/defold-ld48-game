<html>
    <head>
        <style>
            #loading {
                float: left;
                font-weight: bold;
                font-family: sans-serif;
                font-size: 14px;
                font-style: normal;
                font-stretch: normal;
                line-height: normal;
                letter-spacing: 0px;
                padding-top: 12px;
            }
            .link,
            .button,
            #loading {
                margin-right: 12px;
                margin-left: 12px;
            }
            .canvas-app-container {
                background: #ffffff;
                filter: none;
            }
            .canvas-app-canvas {
                background-size: contain;
            }
        </style>
        <script type="text/javascript">
            // WebGL 1.0 transpose/inverse fix
            (function () {
                if (typeof WebGLRenderingContext !== "undefined") {
                    var shaderSourceOld = WebGLRenderingContext.prototype.shaderSource;
                    WebGLRenderingContext.prototype.shaderSource = function (shader, source) {
                        if (source.indexOf("inverse") > -1) {
                            var transpose_inverse =
                                "mat3 transpose(mat3 m) {\n" +
                                "  return mat3(m[0][0], m[1][0], m[2][0],\n" +
                                "              m[0][1], m[1][1], m[2][1],\n" +
                                "              m[0][2], m[1][2], m[2][2]);\n" +
                                "}\n" +
                                "\n" +
                                "mat3 inverse(mat3 m) {\n" +
                                "  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n" +
                                "  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n" +
                                "  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n" +
                                "\n" +
                                "  float b01 = a22 * a11 - a12 * a21;\n" +
                                "  float b11 = -a22 * a10 + a12 * a20;\n" +
                                "  float b21 = a21 * a10 - a11 * a20;\n" +
                                "\n" +
                                "  float det = a00 * b01 + a01 * b11 + a02 * b21;\n" +
                                "\n" +
                                "  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n" +
                                "              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n" +
                                "              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n" +
                                "}\n" +
                                "\n";
                            source = source.replace("void main()", transpose_inverse + "\n\nvoid main()");

                            console.warn("Added inverse/transpose to the GLSL source.");
                        }
                        shaderSourceOld.call(this, shader, source);
                    };
                }
            })();

            // This enables anisotropic filtering on mipmapped textures
            // TODO: Wrap these ifs into the single func
            (function () {
                var maxAniso = 4;

                if (typeof WebGLRenderingContext !== "undefined") {
                    var extAnisotropic = false;
                    var texParameteriOld = WebGLRenderingContext.prototype.texParameteri;
                    WebGLRenderingContext.prototype.texParameteri = function (target, pname, param) {
                        if (
                            target == this.TEXTURE_2D &&
                            pname == this.TEXTURE_MIN_FILTER &&
                            param == this.LINEAR_MIPMAP_LINEAR
                        ) {
                            if (!extAnisotropic) {
                                var ext =
                                    this.getExtension("EXT_texture_filter_anisotropic") ||
                                    this.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                                    this.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                var max = ext ? this.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
                                extAnisotropic = {
                                    ext: ext,
                                    max: Math.min(maxAniso, max),
                                };
                            }

                            if (extAnisotropic.ext) {
                                this.texParameterf(
                                    this.TEXTURE_2D,
                                    extAnisotropic.ext.TEXTURE_MAX_ANISOTROPY_EXT,
                                    extAnisotropic.max
                                );
                            }
                        }

                        texParameteriOld.call(this, target, pname, param);
                    };
                }
            })();
            (function () {
                var maxAniso = 4;

                if (typeof WebGL2RenderingContext !== "undefined") {
                    var extAnisotropic = false;
                    var texParameteriOld = WebGL2RenderingContext.prototype.texParameteri;
                    WebGL2RenderingContext.prototype.texParameteri = function (target, pname, param) {
                        if (
                            target == this.TEXTURE_2D &&
                            pname == this.TEXTURE_MIN_FILTER &&
                            param == this.LINEAR_MIPMAP_LINEAR
                        ) {
                            if (!extAnisotropic) {
                                var ext =
                                    this.getExtension("EXT_texture_filter_anisotropic") ||
                                    this.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                                    this.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                var max = ext ? this.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
                                extAnisotropic = {
                                    ext: ext,
                                    max: Math.min(maxAniso, max),
                                };
                            }

                            if (extAnisotropic.ext) {
                                this.texParameterf(
                                    this.TEXTURE_2D,
                                    extAnisotropic.ext.TEXTURE_MAX_ANISOTROPY_EXT,
                                    extAnisotropic.max
                                );
                            }
                        }

                        texParameteriOld.call(this, target, pname, param);
                    };
                }
            })();
        </script>
    </head>
    <body>
        <div id="app-container" class="canvas-app-container" merge="keep">
            <div id="canvas-container" class="canvas-app-canvas-container">
                <canvas
                    id="canvas"
                    class="canvas-app-canvas"
                    tabindex="1"
                    width="{{display.width}}"
                    height="{{display.height}}"
                ></canvas>
            </div>
            <div class="buttons-background">
                {{#html5.show_fullscreen_button}}
                <div class="button" onclick="Module.toggleFullscreen();">Fullscreen</div>
                {{/html5.show_fullscreen_button}}
                <div id="loading">Loading... 0%</div>
                {{#html5.show_made_with_defold}}
                <div class="link">
                    Made with <a href="https://defold.com/" target="_blank">Defold</a> by
                    <a href="https://twitter.com/aglitchman" target="_blank">@aglitchman</a>
                </div>
                {{/html5.show_made_with_defold}}
            </div>
        </div>
        <script id="engine-setup" type="text/javascript">
            (function () {
                var statusText;
                var setStatus = function (status) {
                    statusText = status;
                    var el = document.getElementById("loading");
                    el.innerText = status;
                };

                if (typeof Progress !== "undefined") {
                    Progress.addListener(function (percentage) {
                        if (isNaN(percentage)) return;
                        var el = document.getElementById("loading");
                        if (!statusText) {
                            if (percentage == 100) {
                                el.innerText = "";
                            } else {
                                el.innerText = "Loading... " + percentage.toFixed(0) + "%";
                            }
                        }
                    });
                }

                extra_params.unsupported_webgl_callback = function () {
                    setStatus("ERROR: WebGL is not supported by your browser.");
                };

                extra_params.can_not_download_file_callback = function () {
                    setStatus("ERROR: Can't download files.");
                };
            })();
        </script>
    </body>
</html>
